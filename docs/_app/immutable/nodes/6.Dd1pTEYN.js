import{f as m,a as o}from"../chunks/CEA9ZyY2.js";import"../chunks/23z7tF0b.js";import{a7 as n,ab as u,a6 as g,af as f,aj as b,ak as t,a9 as i,aa as r}from"../chunks/gZmWwNMp.js";import{h as y}from"../chunks/BVr1Bipn.js";import{s as c}from"../chunks/BCjuOeFR.js";import{b as l}from"../chunks/CD6n3cT_.js";const U=!0,E=Object.freeze(Object.defineProperty({__proto__:null,prerender:U},Symbol.toStringTag,{value:"Module"}));var w=m('<meta name="description" content="Learn how UUID v1 stores time with 100-nanosecond precision using the Gregorian epoch, and how to decode it instantly in your browser."/> <meta property="og:title" content="How UUID v1 Encodes the Exact Timestamp"/> <meta property="og:description" content="Deep technical breakdown of the 60-bit timestamp field that lets you extract the exact creation moment from any Version 1 UUID."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),z=m('<div class="container fade-in post-layout svelte-1apmzc4"><div class="breadcrumbs svelte-1apmzc4"><a class="svelte-1apmzc4">Blog</a> <span>/</span> <p>How UUID v1 Encodes Time</p></div> <article class="prose svelte-1apmzc4"><h1 class="svelte-1apmzc4">How UUID v1 Encodes the Exact Timestamp</h1> <p class="post-meta svelte-1apmzc4">Published: November 28, 2025</p> <p>One of the most powerful features of UUID version 1 is that it embeds the <strong>precise moment of creation</strong> directly in the identifier — no database lookup needed.</p> <p>The timestamp is stored across three fields (time_low, time_mid, time_hi_and_version) forming a single 60-bit integer counting 100-nanosecond intervals since <strong>00:00:00.0000000 UTC on October 15, 1582</strong> — the start of the Gregorian calendar.</p> <h2 class="svelte-1apmzc4">Why 1582? Why 100ns?</h2> <p>The date was chosen because it’s when the Gregorian calendar was introduced. The 100ns resolution (10 million ticks per second) ensures that even millions of UUIDs per second won’t collide.</p> <h2 class="svelte-1apmzc4">Real Example</h2> <p>Take this UUID:</p> <code class="d-block p-3 bg-dark text-light rounded">f81d4fae-7dec-11d0-a765-00a0c91e6bf6</code> <p>Decodes to exactly:</p> <strong>Wednesday, June 30, 1999 21:48:05.150 UTC</strong> <h2 class="svelte-1apmzc4">How This Tool Decodes It</h2> <p>Our generator instantly parses the 60-bit field and displays both:</p> <ul class="svelte-1apmzc4"><li class="svelte-1apmzc4">Human-readable UTC datetime</li> <li class="svelte-1apmzc4">Unix milliseconds since 1970</li></ul> <p>This makes debugging distributed tracing, log correlation, and forensic analysis trivial — you can sort events by ID alone.</p> <h2 class="svelte-1apmzc4">FAQ</h2> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Can clock adjustments break uniqueness?</summary> <p>No. The 14-bit clock sequence increments when time appears to go backward, ensuring monotonicity.</p></details> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Is 100ns precision overkill?</summary> <p>Not for high-frequency systems. Financial trading, telemetry, and gaming often need sub-millisecond accuracy.</p></details> <p class="italic-note svelte-1apmzc4">Try it: Generate a UUID right now — watch the timestamp update in real time.</p></article></div>');function H(p){var e=z();y("1apmzc4",h=>{var s=w(),v=u(g(s),6);t(4),n(()=>c(v,"content",`${l??""}/blog/posts/post2`)),f(()=>{b.title="How UUID v1 Encodes the Exact Timestamp | UUID v1 Generator"}),o(h,s)});var a=i(e),d=i(a);t(4),r(a),t(2),r(e),n(()=>c(d,"href",`${l??""}/blog`)),o(p,e)}export{H as component,E as universal};
